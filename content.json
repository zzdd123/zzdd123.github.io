{"meta":{"title":"朱东的博客","subtitle":"JSU-ZZDD","description":"","author":"朱东","url":"http://example.com","root":"/"},"pages":[{"title":"about","date":"2020-05-04T02:40:15.000Z","updated":"2020-10-10T11:46:57.537Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"friends","date":"2020-05-04T02:40:17.000Z","updated":"2020-10-10T11:49:12.202Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-05-04T02:40:14.000Z","updated":"2020-10-10T11:45:32.729Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-05-04T02:40:13.000Z","updated":"2020-10-10T11:45:06.545Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"contact","date":"2020-05-04T02:40:16.000Z","updated":"2020-10-10T11:47:45.744Z","comments":true,"path":"contact/index.html","permalink":"http://example.com/contact/index.html","excerpt":"","text":""}],"posts":[{"title":"Hello World","slug":"csdn_export_md","date":"2020-10-10T16:00:00.000Z","updated":"2020-10-11T08:36:48.873Z","comments":true,"path":"2020/10/11/csdn_export_md/","link":"","permalink":"http://example.com/2020/10/11/csdn_export_md/","excerpt":"","text":"#inlclude &lt;stdio.h> int main() { printf(\"Hello World\\n\"); return 0; }","categories":[{"name":"测试","slug":"测试","permalink":"http://example.com/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"string用法","slug":"string用法","date":"2020-10-10T16:00:00.000Z","updated":"2020-10-11T13:06:25.857Z","comments":true,"path":"2020/10/11/string用法/","link":"","permalink":"http://example.com/2020/10/11/string%E7%94%A8%E6%B3%95/","excerpt":"","text":"C++ String用法字符串定义方式 getline(cin,str); string s; //生成一个空字符串s string s(str) //拷贝构造函数 生成str的复制品 string s(str,stridx) //将字符串str内“始于位置stridx”的部分当作字符串的初值 string s(str,stridx,strlen) //将字符串str内“始于stridx且长度顶多strlen”的部分作为字符串的初值 string s(cstr) //将C字符串作为s的初值 string s(chars,chars_len) //将C字符串前chars_len个字符作为字符串s的初值。 string s(num,c) //生成一个字符串，包含num个c字符 string s(beg,end) //以区间beg;end(不包含end)内的字符作为字符串s的初值 s.~string() //销毁所有字符，释放内存 示例 string s1(); si = \"\" string s2(\"Hello\"); s2 = \"Hello\" string s3(4, 'K'); s3 = \"KKKK\" string s4(\"12345\", 1, 3); s4 = \"234\"，即 \"12345\" 的从下标 1 开始，长度为 3 的子串 .. substr( )函数用法string s1 = \"this is ok\"; string s2 = s1.substr(2, 4); // s2 = \"is i\" n~n+k之间的字符 s2 = s1.substr(2); // s2 = \"is is ok\" 下标之后所有的字符 .. 字符串的查找s1.find(\"str\") // 查找 str 出现的位置 s1.find(\"Source\", 3)) //从下标3开始查找\"Source\" s1.find_first_of(\"ceo\") //查找第一次出现或 'c'、'e'或'o'的位置 s1.find_last_of('e') //查找最后一个 'e' 的位置 如果字符没找到 将返回一个 int值 string::npos 示例 if(s1.find(\"123\")!=string::npos) { cout&lt;&lt;s1.find(\"123\")&lt;&lt;endl; //找到子串\"123+\" } .. 字符串的替换 string s; s=\"0123456789\"; cout&lt;&lt;s.replace(1,3,\"3333\"); 将从下标1开始的3个字符替换为\"3333\" //此时s=\"03333456789\" s.replace(0,3,5,'0'); 将从下标0开始的3个字符替换为\"00000\"; 此时s=000003456789 .. 字符串的插入 str.insert(1,\"222\"); 在下标1出插入字符串\"222\" s1.insert(2, 4, 'z') 在下标2处插入4个'z' .. 字符串子串的删除string s1(\"hello world\"); s1.erase(1, 3); //将从下标1开始的3个字符删除 s1.erase(5); //删除下标5及其后面的所有字符 reverse( )string str=\"123456\",str2; reverse(str.begin(),str.end()); cout&lt;&lt;str&lt;&lt;endl; reverse_copy(str.begin(),str.end(),str2); cout&lt;&lt;str2&lt;&lt;endl;","categories":[{"name":"程序设计","slug":"程序设计","permalink":"http://example.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"c++ string","slug":"c-string","permalink":"http://example.com/tags/c-string/"}]},{"title":"阶乘(递归)","slug":"阶乘","date":"2020-10-10T16:00:00.000Z","updated":"2020-10-11T08:49:03.403Z","comments":true,"path":"2020/10/11/阶乘/","link":"","permalink":"http://example.com/2020/10/11/%E9%98%B6%E4%B9%98/","excerpt":"","text":"阶乘 int jc(int n) { if(n==1||n==0) return 1; else return n*jc(n-1); }","categories":[{"name":"测试","slug":"测试","permalink":"http://example.com/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"常用算法","slug":"常用算法","date":"2020-10-10T16:00:00.000Z","updated":"2020-10-11T14:46:06.880Z","comments":true,"path":"2020/10/11/常用算法/","link":"","permalink":"http://example.com/2020/10/11/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/","excerpt":"","text":"深度优先搜索题目背景给定一个N*M方格的迷宫，迷宫里有T处障碍，障碍处不可通过。给定起点坐标和终点坐标，问: 每个方格最多经过1次，有多少种从起点坐标到终点坐标的方案。在迷宫中移动有上下左右四种方式，每次只能移动一个方格。数据保证起点上没有障碍。 输入格式 第一行N、M和T，N为行，M为列，T为障碍总数。第二行起点坐标SX,SY，终点坐标FX,FY。接下来T行，每行为障碍点的坐标。 输出格式给定起点坐标和终点坐标，问每个方格最多经过1次，从起点坐标到终点坐标的方案总数。 #include&lt;iostream> #include&lt;cstdlib> #include&lt;cstdio> #include&lt;cmath> using namespace std; int map[6][6];//地图； bool vis[6][6];//走过的标记； int dx[4]={0,0,1,-1}; int dy[4]={-1,1,0,0}; int total,fx,fy,sx,sy,T,n,m,l,r; void dfs(int x,int y) { if(x==fx&amp;&amp;y==fy) { total++; return; } else { for(int i=0;i&lt;=3;i++) { if(vis[x+dx[i]][y+dy[i]]==0&amp;&amp;map[x+dx[i][y+dy[i]]==1) { vis[x][y]=1; dfs(x+dx[i],y+dy[i]); vis[x][y]=0; } } } } int main() { cin>>n>>m>>T; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) map[i][j]=1; scanf (\"%d%d\",&amp;sx,&amp;sy); scanf (\"%d%d\",&amp;fx,&amp;fy); for(int u=1;u&lt;=T;u++) { scanf(\"%d%d\",&amp;l,&amp;r); map[l][r]=0; } dfs(sx,sy); cout&lt;&lt;total; return 0; } .. 广度优先搜索题目背景 给定一个迷宫,求起点到终点的最短路径 5 5 SXXXX ...XX .X... ..XXX ....E #include&lt;iostream> #include&lt;queue> using namespace std; bool visited[50][50]; // 查看地图是否被访问 char map[50][50]; // 标记地图 int dx[4] = { 0,1,0,-1 }; // x方向移动路径 int dy[4] = { 1,0,-1,0 }; int n, m; int starti, startj; int endi, endj; struct Node { int i; int j; int s; // 起点到当前点的最短路径 }; bool judge(int i, int j) { if (j &lt; 0 || j>=m || i &lt; 0 || i >= n) return true; if (visited[i][j]) return true; if (map[i][j]=='X') return true; return false; } Node bfs() { queue&lt;Node> q; Node cur, next; int ni, nj; cur.i = starti; cur.j = startj; cur.s = 0; visited[starti][startj] = true; q.push(cur); while (!q.empty()) { cur = q.front(); q.pop(); if (cur.i == endi &amp;&amp; cur.j == endj) return cur; for (int i = 0; i &lt; 4; i++) { // 四种遍历方法 ni = cur.i + dx[i]; nj = cur.j + dy[i]; if (judge(ni, nj)) { // 如果这种走法不行，尝试下一种走法 continue; } // 可以走 next.i = ni; next.j = nj; next.s = cur.s + 1; q.push(next); } } return cur; } int main() { int N; cin >> N; int sum = 0; while (N--) { cin >> n >> m; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; m; j++) { cin >> map[i][j]; if (map[i][j] == 'S') { starti = i; startj = j; } if (map[i][j] == 'E') { endi = i; endj = j; } } } memset(visited, 0, sizeof(visited)); Node ans = bfs(); sum += ans.s; } cout &lt;&lt; sum &lt;&lt; endl; } ... 最短路算法dij模板普通版 #include &lt;iostream> #include &lt;cstdio> #define MAX 1000000 using namespace std; int arcs[10][10];//邻接矩阵 int D[10];//保存最短路径长度 int p[10][10];//路径 int final[10];//若final[i] = 1则说明 顶点vi已在集合S中 int n = 0;//顶点个数 int v0 = 0;//源点 int v,w; void ShortestPath_DIJ() { for (v = 0; v &lt; n; v++) //循环 初始化 { final[v] = 0; D[v] = arcs[v0][v]; for (w = 0; w &lt; n; w++) p[v][w] = 0;//设空路径 if (D[v] &lt; MAX) {p[v][v0] = 1; p[v][v] = 1;} } D[v0] = 0; final[v0]=1; //初始化 v0顶点属于集合S //开始主循环 每次求得v0到某个顶点v的最短路径 并加v到集合S中 for (int i = 1; i &lt; n; i++) { int min = MAX; for (w = 0; w &lt; n; w++) { //我认为的核心过程--选点 if (!final[w]) //如果w顶点在V-S中 { //这个过程最终选出的点 应该是选出当前V-S中与S有关联边 //且权值最小的顶点 书上描述为 当前离V0最近的点 if (D[w] &lt; min) {v = w; min = D[w];} } } final[v] = 1; //选出该点后加入到合集S中 for (w = 0; w &lt; n; w++)//更新当前最短路径和距离 { /*在此循环中 v为当前刚选入集合S中的点 则以点V为中间点 考察 d0v+dvw 是否小于 D[w] 如果小于 则更新 比如加进点 3 则若要考察 D[5] 是否要更新 就 判断 d(v0-v3) + d(v3-v5) 的和是否小于D[5] */ if (!final[w] &amp;&amp; (min+arcs[v][w]&lt;D[w])) { D[w] = min + arcs[v][w]; // p[w] = p[v]; p[w][w] = 1; //p[w] = p[v] + [w] } } } } int main() { cin >> n; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { cin >> arcs[i][j]; } } ShortestPath_DIJ(); for (int i = 0; i &lt; n; i++) printf(\"D[%d] = %d\\n\",i,D[i]); return 0; } 采用优先队列 #include &lt;cstdio> #include &lt;queue> #include &lt;cstring> #include &lt;algorithm> const int MAXN = 100000 + 10; const int MAXM = 200000 + 10; int n,m,begin,end,dis[MAXN],vis[MAXN],tot,last[MAXN],s; struct Edge{ int u,v,w,to; Edge(){} Edge(int u, int v, int w, int to) : u(u), v(v), w(w), to(to) {} } e[MAXM*2]; inline void add(int u,int v,int w) { e[++tot] = Edge(u,v,w,last[u]); last[u] = tot; } struct st{ int n,w; bool operator &lt;(const st &amp;a) const { return w > a.w;//把STL里面的小于号全部换为大于号 } }; std::priority_queue&lt;st> q; inline void dijkstra() { for(int i=1; i&lt;=n; i++) dis[i] = 0x7fffffff; dis[s] = 0; q.push((st){s,0}); while(!q.empty()) { int x = q.top().n; q.pop(); if (vis[x])continue; vis[x] = 1; for(int i=last[x]; i; i=e[i].to) { int y = e[i].v; if (dis[x] + e[i].w &lt; dis[y]){ dis[y] = dis[x] + e[i].w; q.push((st){y,dis[y]}); } } } } int main() { scanf(\"%d %d %d\",&amp;n,&amp;m,&amp;s); for(int i=1; i&lt;=m; i++) { int u,v,w; scanf(\"%d %d %d\",&amp;u,&amp;v,&amp;w); add(u,v,w); } dijkstra(); for(int i=1; i&lt;=n; i++) printf(\"%d \", dis[i]); } .. 最小生成树普里姆算法 #include &lt;iostream> #include &lt;cstdio> #include &lt;algorithm> #include &lt;vector> #include &lt;cstring> using namespace std; const int maxx=1000000000; int ver[100][100]; int dis[100]; int vis[100]; int n; int b; void init() { for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) { if(i==j) { ver[i][j]=ver[j][i]=0; } else ver[i][j]=ver[j][i]=maxx; } } int sum() { int res=0; memset(vis,0,sizeof(vis)); vis[1]=1; for(int i=2;i&lt;=n;i++){ dis[i]=ver[1][i]; //cout&lt;&lt;dis[i]&lt;&lt;endl; } for(int i=2;i&lt;=n;i++) { int minn=maxx,k=-1; for(int j=1;j&lt;=n;j++) { if(!vis[j]&amp;&amp;dis[j]&lt;minn&amp;&amp;dis[j]!=0) { minn=dis[j]; k=j; //cout&lt;&lt;minn&lt;&lt;endl; } } res+=minn; vis[k]=1; for(int v=1;v&lt;=n;v++) { if(!vis[v]) { dis[v]=min(dis[v],ver[k][v]); } } } return res; } int main() { cin>>n>>b; init(); for(int i=1;i&lt;=b;i++) { int l,r,ave; cin>>l>>r>>ave; ver[l][r]=ver[r][l]=ave; } cout&lt;&lt;sum()&lt;&lt;endl; return 0; } .. 素数判断普通版 for(i=2; i&lt;=n; i++) { for(j=2; j&lt;=sqrt(i); j++) { if( j%i==0 ) break; } if( j>sqrt(i) ) printf(\"%d是质数\\n\",i); } ..快速版 bool prime[1000]; void eratos(int n){ for(int i=0;i&lt;=n;i++) //列举所有整数作为候选 prime[i]=true; //删除0和1 prime[0]=prime[1]=false; //留下i,删除i的倍数 for(int i=2;i&lt;=sqrt(n);i++){ if(prime[i]){ int j=i+i; while(j&lt;=n){ prime[j]=false; j+=i; } } } } .. 快速幂 long long fastPower(long long base, long long power) { long long result = 1; while (power > 0) { if (power % 2 == 0) { //如果指数为偶数 power = power / 2;//把指数缩小为一半 base = base * base % 1000;//底数变大成原来的平方 } else { //如果指数为奇数 power = power - 1;//把指数减去1，使其变成一个偶数 result = result * base % 1000;//此时记得要把指数为奇数时分离出来的底数的一次方收集好 power = power / 2;//此时指数为偶数，可以继续执行操作 base = base * base % 1000; } } return result;","categories":[{"name":"程序设计","slug":"程序设计","permalink":"http://example.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"算法模板","slug":"算法模板","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"}]}],"categories":[{"name":"测试","slug":"测试","permalink":"http://example.com/categories/%E6%B5%8B%E8%AF%95/"},{"name":"程序设计","slug":"程序设计","permalink":"http://example.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"c++ string","slug":"c-string","permalink":"http://example.com/tags/c-string/"},{"name":"算法模板","slug":"算法模板","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"}]}